# Rechtschreib fehler möglich, da dieser Text mit extremer Crunch Time geschrieben wurde! Trotzdem habe ich versucht die Fehler zu beheben.

# BIOS
Das BIOS (Basic Input Output System) ist die Firmware des <LINK INTERN Mainboard>Mainboards</LINK>, welche aufgaben wie z. B. die Hardware Initialisierung oder die Bereitstellung von Runtime Services (Siehe unten für weitere Informationen) für das <LINK INTERN OS>OS</LINK> und deren Programme übernimmt. Ein BIOS ist eigentlich auf jedem Gerät zu finden, wo der Entwickler/Hersteller die Hardware Initialisierung selber übernimmt. Geräte, bei denen dies nicht der Fall ist, sind z. B. der 6502 (Die <LINK INTERN CPU>CPU</LINK> der NES oder des C64) oder der Ricoh 5A22 aus der SNES.

## Abhänigkeiten
Damit das BIOS funktioniert, wird die <LINK INTERN CPU>CPU</LINK> und der <LINK INTERN RAM>RAM</LINK> benötigt. Eine <LINK INTERN GPU>GPU</LINK> wird nicht zwingend benötigt, da die gesamten ausgaben, wenn überhaupt benötigt, auch z. B. über eine <LINK INTERN serielle Schnittstelle> serielle Schnittstelle</LINK> ausgegeben werden können. Allerdings muss das BIOS dafür speziell dafür entwickelt werden, da die BIOS’es die auf normalen <LINK INTERN Mainboard>Mainboards</LINK> installiert sind immer versuchen einen <LINK INTERN GPU>GPU</LINK> zu Initialisieren. Sollte dies nicht Funktionieren, da z. B. da kein <LINK INTERN GPU>GPU</LINK> verbaut ist, wird das BIOS in den Fail-mode gehen, wo er dann bis zum Abschalten des Computers verbleibt. Später noch bei dem „Power On Self Test„ erklärt.

## User Interface
Das User Interface des BIOS ist ein Text basierte Oberfläche, welche zur Konfiguration oder Überprüfung der Hardware dient. Allerdings besitzt nicht jedes BIOS so ein User Interface. Denn z. B. bei der PS4 besitzt das BIOS kein User Interface oder jegliche, für den Nutzer ersichtlichen, ausgaben.

## Runtime Services
Runtime Services sind Funktionen die das BIOS dem <LINK INTERN OS>OS</LINK> sowie deren Programmen zur Verfügung stellt. Diese übernehmen aufgaben wie z. B. das Ansprechen der <LINK INTERN Netzwerkschnittstelle>Netzwerkschnittstelle</LINK>, <LINK INTERN Keyboard>Keyboard</LINK> Input oder Speicher Operationen. Diese dienen zur Standardisierung von solchen Aufgaben welche die Kompatibilität erhöht, da das Programm auf nicht oder nur minimal angepasst werden muss, wenn es auf einem AMD statt Intel <LINK INTERN CPU>CPU</LINK> läuft.

### Overclocking
Das Overclocking, oder auch Übertakten genannt, ist das Verändern der Hardware Eigenschaften, welche die Leistung beeinflussen. Damit dies Funktioniert muss das <LINK INTERN Mainboard>Mainboard</LINK> sowie die Komponenten diese Eigenschaft auch Unterstützen. Übertaktet werden zurzeit eigentlich nur die <LINK INTERN CPU>CPU</LINK>, <LINK INTERN GPU>GPU</LINK>, <LINK INTERN RAM>RAM</LINK> und in manchen Fällen auch der <LINK INTERN Monitor>Monitor</LINK>. Hierbei ist das Overclocking komplett aus dem <LINK INTERN OS>OS</LINK> heraus durchführbar, wofür allerdings das BIOS dies Unterstützen muss, sowie spezielle Programme benötigt werden, wie z. B. für <LINK INTERN RAM>RAM</LINK> und <LINK INTERN CPU>CPU</LINK> AMD Ryzen Master <IMG bios_0006.png>, für die <LINK INTERN GPU>GPU</LINK> MSI Afterburner <IMG bios_0005.png> oder für den Monitor das NVIDIA Controle Panel vom Treiber <IMG bios_0007.png>

#### CPU
Die Möglichkeiten die man vom BIOS zum Übertakten bekommt, sind <LINK INTERN CPU>Prozessor</LINK> abhängig. Je nachdem was der <LINK INTERN CPU>Prozessor</LINK> unterstützt bekommt man andere Optionen. Die meist verwendeten Optionen für das Übertakten einer <LINK INTERN CPU>CPU</LINK> sind der Multiplikator, die Taktrate (in MHz) und die Core Spannung. Je nach <LINK INTERN Mainboard>Mainboard</LINK> stehen einen auch noch weitere Optionen, wie z. B. die Spannung der North Bridge zur Verfügung. Solch ein Übertaktung Interface könnte wie folgt aussehen <IMG bios_0008.png>

#### RAM
Auch hier gibt das BIOS einen die Möglichkeit den <LINK INTERN RAM>RAM</LINK> zu übertakten. Der <LINK INTERN RAM>RAM</LINK> muss dies genau wie bei der <LINK INTERN CPU>CPU</LINK> unterstützen. Die Möglichkeiten, die man vom BIOS bekommen kann, zum übertakten sind z. B. die Spannung, Timings und/oder die Taktrate (in MHz) anzupassen.

### Boot Priorität
In dem Menü der Boot Priorität kann festgelegt werden, in welcher reinfolge, von Speichermedien, dass BIOS versuchen soll das <LINK INTERN OS>OS</LINK> zu starten. Das ist so gemeint das, wenn er auf dem ersten Speichermedium kein System findet versucht er von dem zweiten das System zu laden und so weiter. Sobald er das passende Gerät gefunden hat, wird der Interrupt 0x19 ausgeführt, welcher letzten Endes das System startet. Kann er letzten Endes gar kein <LINK INTERN OS>OS</LINK> Starten so zeigen die meisten BIOS’s Nachrichten wie „no boot device found„ an.

### Boot Menu
Es ist ein Menü wo alle Speicher Medien aufgelistet werden, wo man dann angeben soll von welchem das BIOS versuchen soll, zu starten. Klappt dies nicht, weil er z. B. nichts zum Starten findet, fängt er einfach an die Bootpriorität abzuarbeiten. Die Gerätenummer des Gerätes von welchem letzten Endes gestartet wird, wird im Register DL gespeichert.

### Firmware Update
Um ein Firmware Update durchzuführen gibt es mehrere Möglichkeiten. Diese wären aus dem <LINK INTERN OS>OS</LINK> heraus oder über das BIOS selbst. Dafür wurde die Update-Datei auf einen, meist in FAT32 formatierten, USB-Stick kopiert und den Computer in einen dafür vorgesehenen Flash Modus gestartet. In diesem kann die Firmware nun sicher installieren, ohne das ein anderes Programm einen Fehler während der Installation verursachen kann. Dies ist sehr gut, denn sollte ein solches Firmware Update fehlschlagen fährt der Rechner meistens nicht mehr hoch da sich die Hardware nicht Initialisieren lässt. Um ein solchen Fehler zu beheben, muss man den Chip neu beschreiben. Entweder der Hersteller hat dafür einen speziellen Modus eingebaut oder man muss mit z. B. einer speziellen Klammer und einem USB Flasher den Chip neu beschreiben. Außerdem gibt es die Möglichkeit das <LINK INTERN Mainboard>Mainboard</LINK> zum Hersteller zu schicken und von denen machen zu lassen.

## Hardware Initialisierung und Boot
Sobald der Computer eingeschaltet wird, benötigt das Netzteil eine gewisse Zeit bevor es die richtige Spannung abgeben kann. Da keinerlei Werten im <LINK INTERN RAM>RAM</LINK> oder den <LINK INTERN CPU>CPU</LINK> Registern stehen, weiß die <LINK INTERN CPU>CPU</LINK> auch nicht wo das BIOS sich auf dem Chip befindet. Aus diesem Grund fangen die <LINK INTERN CPU>CPU’s</LINK> immer bei der Initialisierung an den Code des BIOS Chips anstelle 0xFFF0 auszuführen. Dieser ist meistens ein Jump Befehl, welcher zu dem richtigen Einstiegspunkt des BIOS führt. Nun wird ein „Power On Self Test„ durchgeführt, welcher die Peripheriegeräte, die Festplatten, den <LINK INTERN RAM>RAM</LINK> sowie andere wichtige Hardware Initialisiert. Damit das BIOS auch weiß wie viel <LINK INTERN RAM>RAM</LINK> er zur Verfügung hat setzt er das Ende des Speichers wodurch er die genaue Größe erhält. Sollte dieser Fehl schlagen stellt dies das BIOS mithilfe von Status LED’s dar (Also z. B. wenn er bei dem <LINK INTERN RAM>RAM</LINK> hängen bleibt, leuchtet <LINK INTERN RAM>RAM</LINK>), mit Biep Codes oder mit Error Codes welche auf einem Zahlen Display stehen. Sollte dies aber funktioniert haben, sucht das BIOS normalerweise nach dem <LINK INTERN GPU>GPU</LINK> BIOS, welches normalerweise an der Stelle 0xC000 liegt und führt dieses aus. Nachdem das <LINK INTERN GPU>GPU</LINK> BIOS durch ist sucht das <LINK INTERN Mainboard>Mainboard</LINK> BIOS nach weiteren BIOS’en, eigentlich haben die IDE/ATA Festplatten noch solch ein BIOS welches an der Stelle 0xC800 zu finden ist. Das macht er so lange bis alle BIOS’se ausgeführt wurden. Dies ist der Moment wo der Computer das erste Mal etwas auf dem Bildschirm darstellt. Denn nun wird der Startup Screen, wie z. B. ein Bild des Herstellers oder Hardware Informationen gerendert. Als nächstes versucht der Computer durch weitere Tests herauszufinden welche Hardware verbaut ist und versucht diese passend zu Konfigurieren.
Außerdem sucht das BIOS nun nach Plug’n Play Geräten, wie z. B. einer Maus. Nun beginnt der Boot Prozess, welcher erst einmal wie oben beschrieben das passende Boot Medium sucht und dann lässt es die <LINK INTERN CPU>CPU</LINK> den Code des Interrupts 0x19 ausführen, was den Start des Systems verursacht.

# UEFI
Das UEFI ist eine Firmware, welche das Traditionelle BIOS als Firmware ablöst. Hierbei übernimmt das UEFI noch den Job als Mittelmann zwischen der eigenen Firmware und des <LINK INTERN OS>OS</LINK>. Dies soll es Entwicklern vereinfachen auf Firmware Funktionen zuzugreifen und die Kompatibilität erhöhen. Das UEFI als Firmware hat gegenüber dem BIOS auch noch weitere Vorteile, wie z. B. das es die Verwendung von Partitionen über 2 TB unterstützt mittels einer GPT Partitionstabelle, <LINK INTERN CPU>CPU</LINK> unabhängige Architekturen sowie Treiber oder Rück-/aufwärts Kompatibilität.

## Abhänigkeiten
Die Abhängigkeiten sind identisch mit denen des BIOS.

## User Interface
Das User Interface des UEFI’s besitzt meistens im Vergleich zu dem des BIOS eine wirkliche Grafische Oberfläche, welche ebenfalls eine Maus Unterstützung bietet. In diesem User Interface gibt es auch richtige Button’s, Text felder und sonstiges, wie man es aus den <LINK INTERN OS>OS’en</LINK> kennt. Dies hat den Vorteil das es einfacher ist es zu bedienen und das es Schöner aussieht. Allerdings benötigt das UEFI, für so etwas auf jeden fall eine Grafikkarte. Um zu veranschaulichen, wie solch eine UEFI Firmware aussehen könnte, werden hier nun ein paar Bilder eingeblendet.
<IMG bios_0000.png>
<IMG bios_0001.png>
<IMG bios_0004.png>

## Hardware Initialisierung und Boot
Die Hardware Initialisierung ist soweit identisch zu der vom BIOS. Allerdings unterscheidet sich das Booten vom BIOS sehr stark da das UEFI schon allein vier verschiedene Bootmodes besitzt. Diese wären „UEFI booting„, „CSM booting„, „Network booting„ und „Secure boot„.

### UEFI booting
UEFI benötigt zum Booten keinen Boot Sektor, sondern auf einen Boot Manager. Dieser führt den definierten Bootloader aus, welcher in der zuvor geladenen Bootkonfiguration zu finden ist. Zudem kann automatisch ein Bootloader auf einem Gerät gefunden werden, da es hierfür standardisierte Namen und Pfade gibt. Also als Beispiel müsste für einen x86_64 Computer der Bootloader an der stelle <EFI_SYSTEM_PARTITION>/EFI/BOOT/BOOTX64.efi liegen. Dies ermöglicht es auch von tragbaren Datenträger, wie z. B. ein USB-Stick, zu Booten. Hierbei erkennt das UEFI auch welche Partitionstabelle vorliegt. Sollte auf dem Startmedium, von welcher gestartet werden soll eine GPT-Partitionstablle vorliegen so verbleibt das UEFI im „UEFI booting„. Sollte allerdings das Startmedium einen MBR Boot Sector besitzen, so wechseln die meisten Firmwares zu dem „CSM booting„. Auch wenn die UEFI Spezifikation eine volle MBR Unterstützung vorsieht, verhindert dies auf den meisten Firmwares das „UEFI booting„ mit MBR Datenträger.

### CSM booting
Zu dem „CSM booting„ gibt es nicht viel zu sagen, da es eins zu eins das Booten wie im BIOS ist. Dies wurde bereits etwas weiter oben erklärt.

### Network booting
Bei dem „Network booting„ wird das sogenannte Preboot eXecution Environment (PXE) verwendet. Damit PXE etwas Starten kann, fragt dieser bei dem DHCP Server nach einem PXE Server nach. Sollte es einen im Netzwerk tatsächlich geben und der DHCP Server diesen auch kennt, übermittelt der DHCP Server die IP-Adresse an den Computer, welcher dann per TFTP versucht die benötigten Dateien zu laden und auszuführen. Dabei bleiben diese auf dem Rechner und werden dann von dem PXE Server geladen, sobald der Computer diese braucht. Dies hat z. B. den Vorteil, dass die Installations Geschwindigkeit von Windows erhöht werden kann. Die Installations Geschwindigkeit ist hierbei davon abhängig wie schnell das interne Netzwerk ist, wie schnell der Speicher des Servers sowie des Computers ist und natürlich wie schnell der Server und der Computer selbst ist. Ein weiterer Vorteil ist, dass man einfacher Windows auf mehreren Computern zur selben Zeit installieren kann, da mit PXE nicht mehr für jeden Computer ein Datenträger mit der Installation benötigt wird, sondern einfach alle sich die Installation von dem Server laden können. Zudem wurde bei der PXE 2.5 Version die Möglichkeit hinzugefügt, statt eines TFTP Servers einen HTTP Server zu verwenden. Allerdings hat ein HTTP Server in diesem Fall keine mir bekannten Vorteile gegenüber eines TFTP Servers.

### Secure boot
Secure boot ist einer Methode die es nur Signierter Software erlaubt zu starten. Das wird so gemacht, dass wenn es eingeschaltet ist z. B. Windows bei der Installation einen Schlüssel in der Firmware ablegt welcher dann zur Authentifizierung der vor dem Windows Start geladenen Software dient. Dies verhindert z. B. das ein Virus sich in den Start Prozess einhängen kann, da dann z. B. der Bootloader von Windows nicht mehr Signiert ist.
