# Rechtschreib fehler möglich, da dieser Text mit extremer Crunsh Time geschrieben wurde!

# BIOS
Das BIOS (Basic Input Output System) ist die Firmware des <LINK INTERN Mainboard>Mainboards</LINK>, welche aufgaben wie z.B. die Hardware Initialisierung oder die bereitstellung von Runtime Services (Siehe unten für weitere Informationen) für das OS und deren Programme übernimmt. Ein BIOS ist eigentlich auf jedem Geräten zu finden wo der Entwickler die Hardware Initialisierung selber übernimmt. Geräte bei denen dies nicht der Fall ist sind z.B. der 6502 (Die CPU der NES oder des C64) oder der Ricoh 5A22 aus der SNES.

## Abhänigkeiten
Damit das BIOS funktioniert, wird die CPU und der RAM benötigt. Eine GPU wird nicht zwingend benötigt, da die gesammten ausgaben, wenn überhaupt benötigt, auch z.B. über eine <LINK INTERN Serielle Schnittstelle>Serielle Schnittstelle</LINK> ausgegeben werden können. Allerdings muss das BIOS dafür speziell dafür entwickelt werden, da die BIOS's die auf nomalen <LINK INTERN Mainboard>Mainboards</LINK> installiert sind immer versuchen einen <LINK INTERN GPU>GPU</LINK> zu Initialisieren und sollte dies nicht Funktionieren, da z.B. da kein <LINK INTERN GPU>GPU</GPU> verbaut ist, wird das BIOS in den Fail-mode gehen, wo er dann bis zum abschalten des Computers verbleibt. Später noch bei dem "Power On Self Test" erklärt.

## User Interface
Das User Interface des BIOS ist eine Text Basierte oberfläche, welche zur Konfiguration oder überprüfung der Hardware dient. Allerdings besitzt nicht jedes BIOS so ein User Interface. Denn z.B. bei der PS4 oder der Nintendo Switch besitzt das BIOS kein User Interface oder jegliche, für den nutzer ersichtlichen, ausgaben.

## Runtime Services
Runtime Services sind funktionen die das BIOS dem OS sowie deren Programmen zur verfügung stellt. Diese übernehmen aufgaben wie z.B. das ansprechen der Netzwerk Schnittstelle, Keyboard Input oder Speicher Operationen. Diese dienen zur Standartisierung von solchen Aufgaben welche die Kompatiblität erhöht, da das Programm auf nicht oder nur minimal angepasst werden muss wenn es auf einem AMD statt Intel CPU läuft.

### Overclocking
Das Overcloking, oder auch Übertackten gennant, ist das verändern der Hardware eigenschaften, welche die Leistung beeinflussen. Damit dies Funktioniert muss das <LINK INTERN Mainboard>Mainboard</LINK> sowie die Komponenten diese eigenschaft auch Unterstützen. Übertaktet werden zurzeit eigentlich nur die <LINK INTERN CPU>CPU</LINK>, <LINK INTERN GPU>GPU</LINK>, <LINK INTERN RAM>RAM</LINK> und in manchen fällen auch der <LINK INTERN Monitor>Monitor</LINK>. Hierbei ist das Overclocking komplett aus dem OS heraus durchführbar, wofür allerdings das BIOS dies Unterstützen muss, sowie spezielle Programme benötigt werden, wie z.B. für RAM und CPU AMD Ryzen Master <IMG bios_0006.png>, für die GPU MSI Afterburner <IMG bios_0005.png> oder für den Monitor das NVIDIA Controle Panel vom Treiber <IMG bios_0007.png>.

#### CPU
Die möglichkeiten die man vom BIOS zum Übertackten bekommt sind Prozessor abhängig. Je nach dem was der Prozessor unterstützt bekommt man andere Optionen. Die Meist verwendesten Optionen für das Übertakten einer CPU sind der Multiplikator, die Taktrate (in MHz) und die Core Spannung. Je nach Mainboard stehen einen auch noch weitere Optionen, wie z.B. die Spannung der North Bridge zur verfügung. Solch ein Übertacktungs Interface könnte wie folgt aussehen <IMG bios_0008.png>

#### RAM
Auch hier gibt das BIOS einen die möglichkeit den RAM zu übertakten. Der RAM muss dies genau wie bei der CPU unterstützen. Die möglichkeiten die man vom BIOS bekommen kann zum übertackten sind z.B. die Spannung, Timings und/oder die Taktrate (in MHz) anzupassen.

### Boot Priorität
In dem Menu der Boot Priorität kann festgelegt werden in welcher reinfolge, von Speichermedien, dass BIOS versuchen soll das OS zu starten. Das ist so gemeint das wenn er auf dem ersten Speichermedium kein System findet er versucht von dem zweiten das System zu laden und so weiter. Sobald er das passende Gerät gefunden hat wird der Interupt 0x19 ausgeführt, welcher letzten endes das System startet. Kann er letzten endes garkein OS Starten so zeigen die meisten BIOS's Nachrichten wie "no boot device found" an.

### Boot Menu
Es ist ein Menu wo alle Speicher medien aufgelistet werden, wo man dann angeben soll von welchem das BIOS versuchen soll zu Starten. Klapt dies nicht, weil er z.B. nichts zum Starten findet, fängt er einfach an die Boot Priorität abzuarbeiten. Die Gerätnummer von welchem letzten endes gestartet wird, wird im Register DL gespeichert.

### Firmware Update
Um ein ein Firmware Update durchzuführen gibt es mehrere möglichkeiten. Diese wären aus dem OS heraus oder über das BIOS selbst. Dafür wurde die Update Datei auf einen, meist in FAT32 Formatierten, USB-Stick kopiert und den Computer in einen dafür vorgesehenden Flash modus gestarte. In diesem kann die Firmware nun sicher installieren, ohne das ein anderes Programm einen Fehler während der Installation verursachen kann. Dies ist sehr gut denn sollte ein solches Firmware Update fehlschlagen fährt der Rechner meistens nicht mehr hoch da sich die Hardware nicht Initialisieren lässt. Um ein solchen Fehler zu beheben muss man den Chip neu beschreiben. Entweder der Hersteller hat dafür einen Spizellen modus eingebaut oder man muss mit z.B. einer spizellen Klammer und einem USB Flasher den Chip neu beschreiben. Außerdem gibt es die möglichkeit das Mainboard zum Hersteller zu schicken und von dennen machen zu lassen.

## Hardware Initialisierung und Boot
Sobald der Computer eingeschaltet wird, benötigt das <LINK INTERN Netzteil>Netzteil</LINK> eine gewisse zeit bevor es die richtige Spannung abgeben kann. Da keinerlei Werten im <LINK INTERN RAM>RAM</LINK> oder den CPU Registern stehen, weiß die CPU auch nicht wo das BIOS sich auf dem Chip befindet. Aus diesem Grund fangen die <LINK INTERN CPU>CPU's</LINK> immer bei der Initialisierung an den Code des BIOS Chip's an stelle 0xFFF0 auszuführen. Dieser ist meistens ein Jump befehl, welcher zu dem richtigen Einstigspunkt des BIOS führt. Nun wird ein "Power On Self Test" durchgeführt, welcher die Peripheriegeräte, die Festplatten, den <LINK INTERN RAM>RAM</LINK> sowie andere wichtige Hardware Initialisiert. Damit das BIOS auch weiß wie viel <LINK INTERN RAM>RAM</LINK> er zur verfügung hat setzt er das Ende des Speichers wodurch er die genaue größe erhällt. Sollte dieser Fehl schlagen stellt dies das BIOS mit hilfe von Status LED's da (Also z.B. wenn er bei dem RAM hängen bleibt läuchtet RAM), mit Biep codes oder mit Error Codes welche auf einem Zahlen Display stehen. Sollte dies aber funktioniert haben, sucht das BIOS normalerweise nach dem GPU BIOS, welches normalerweise an der Stelle 0xC000 ligt und führt dieses aus. Nachdem das GPU BIOS durch ist sucht das Mainboard BIOS nach weiteren BIOS'en, eigentlich haben die IDE/ATA Festplatten noch solch ein BIOS welches an der Stelle 0xC800 zu finden ist. Das macht er solange bis alle BIOS'se ausgeführt wurden. Dies ist der moment wo der Computer das erste mal etwas auf dem Bildschirm darstellt. Denn nun wird der Startup screen, wie z.B. ein Bild des Herstellers oder Hardware Informationen gerendert. Als nächstes versucht der Computer durch weitere Tests herauszufinden welche Hardware verbaut ist und versucht diese passend zu Konfigurieren.
Außerdem sucht das BIOS nun nach Plug'n Play Geräten, wie z.B. einer Maus. Nun beginnt der Boot Prozess, welcher erst einmal wie oben beschrieben das passende Boot medium sucht und dann lässt die CPU den Code des Interupts 0x19 ausführen, was den Start des Systems verursacht.

# UEFI
Das UEFI ist eine Firmware, welche das Traditionelle BIOS als Firmware ablöst. Hierbei übernimmt das UEFI noch den Job als Mittelmann zwischen der eigenen Firmware und des OS. Dies soll es Entwicklern vereinfachen auf Firmware Funktionen zuzugreifen und die Kompatiblität erhöhen. Das UEFI als Firmware hat gegenüber dem BIOS auch noch weitere Vorteile, wie z.B. das es die verwendung von Partitionen über 2TB unterstützt mittels einer GPT Partitionstabelle, CPU unabhänige Architekturen sowie Treiber oder Rück-/aufwärts Kompatiblität.

## Abhänigkeiten
Die Abhängikeiten sind identisch mit dennen des BIOS.

## User Interface
Das User Interface des UEFI's besitzt meistens im vergleich zum dem des BIOS eine wirkliche Grafische Oberfläche, welche ebenfals eine Maus unterstützung bietet. In diesem User Interface gibt es auch richtige Button's, Text felder und sonstiges, wie man es aus den OS'en kennt. Dies hat den Vorteil das es einfacher ist es zu bedienen und das es Schöner aussieht. Allerdings benötigt das UEFI, für soetwas auf jeden fall eine <LINK INTERN GPU>Grafikkarte</LINK>. Um zu veranschaulichen wie solch eine UEFI Firmware aussehen könnte, werden hier nun ein paar Bilder eingeblendet.
<IMG bios_0000.png>
<IMG bios_0001.png>
<IMG bios_0004.png>

## Hardware Initialisierung und Boot
Die Hardware Initialisierung ist soweit identisch zu der vom BIOS. Allerdings unterscheidet sich das Booten bom BIOS sehr stark da das UEFI schon allein vier verschidene Bootmodes besitzt. Diese wären "UEFI booting", "CSM booting", "Network booting" und "Secure boot".

### UEFI booting
UEFI benötigt zum Booten keinen Boot Sector, sondern auf einen Boot Manager. Dieser führt den definierten Bootloader aus, welcher in der zuvor geladenen Bootkonfiguration zu finden ist. Zudem kann automatisch ein Bootloader auf einem Gerät gefunden werden, da es hierfür standartisierte Namen und Pfade gibt. Also als Beispiel müsste für einen x86_64 Computer der Bootloader an der stelle <EFI_SYSTEM_PARTITION>/EFI/BOOT/BOOTX64.efi ligen. Dies ermöglicht es auch von Tragbaren Datenträger, wie z.B. ein USB Stick, zu Booten. Hierbei erkennt das UEFI auch welche Partitionstablle vorligt. Sollte auf dem Startmedium, von welcher gestartet werden soll eine GPT-Partitionstablle vorliegen so verbleibt das UEFI im "UEFI booting". Sollte allerdings das Startmedium einen MBR Boot Sector besitzen, so wechseln die meisten Firmwares zu dem "CSM booting". Auch wenn die UEFI Spezifikation eine volle MBR unterstützung vorsieht, verhindert dies auf den meisten Firmwares das "UEFI booting" mit MBR Datenträger.

### CSM booting
Zu dem "CSM booting" gibt es nicht viel zu sagen, da es eins zu eins das Booten wie im BIOS ist. Dies wurde bereits etwas weiter obern erklärt.

### Network booting
Bei dem "Network booting" wird das sogennante Preboot eXecution Environment (PXE) verwendet. Damit PXE etwas Starten kann, fragt dieser bei dem DHCP Server nach einem PXE Server nach. Sollte es im Netzwerk tatsächlich geben und der DHCP Server diesen auch kennt, übermittelt der DHCP Server die IP Adresse an den Computer, welcher dann per TFTP versucht die benötigten Dateien auszuführen. Dabei bleiben diese auf dem Rechner und werden dann vom PXE Server geladen sobald der Computer diese braucht. Dies hat z.B. den Vorteil, dass die Installations geschwindigkeit von Windows erhöht werden kann. Die Installations geschwindigkeit ist hierbei davon abhänig wie schnell das interne Netzwerk ist, wie schnell der Speicher des Servers sowie des Computer ist und natürlich wie schnell der Server und der Computer selbst ist. Ein weiterer vorteil ist, dass man einfacher Windows auf mehreren Computern zur selben zeit installieren kann, da mit PXE nicht mehr für jeden Computer ein Datenträger mit der Installation benötigt wird, sondern einfach alle sich die Installation von dem Server laden können. Zudem wurde bei der PXE 2.5 Version die möglichkeit hinzugefügt statt eines TFTP Servers einen HTTP Server zu verwenden. Allerdings hat ein HTTP Server in diesem Fall keine mir bekannten Vorteile gegenüber eines TFTP Servers.

### Secure boot
Secure boot ist einer Methode die es nur Signierter Software erlaubt zu starten. Das wird so gemacht, dass wenn es eingeschaltet ist z.B. Windows bei der Installation einen Schlüßel in der Firmware ablegt welcher dann zur authentifizierung der vor dem Windows Start geladenen Software dient. Dies verhindert z.B. das ein Virus sich in denn Start Prozess einhängen kann, da dann z.B. der Bootloader von Windows nicht mehr Signiert ist.